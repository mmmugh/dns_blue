#pragma once

//Because the tests are simple, the declarations and definitions are in the header file.

#include "MinHook.h"
#include <winsock.h>
#include <iostream>
using namespace std;

typedef int (WINAPI *RECVFROM)(SOCKET, char*, int, int, sockaddr*, int*);

// Pointer for calling original MessageBoxW.
RECVFROM fpRecvfrom = NULL; //was fpMessageBoxW

// Detour function which overrides MessageBoxW.
char* DetourRecvfrom(SOCKET   s,
		             char     *buf,
		             int      len,
				     int      flags,
		             sockaddr *from,
					 int      *fromlen)
{
	char *buffer = (char *)malloc(sizeof(char) * len + 1);
	fpRecvfrom(s, buffer, len, flags, from, fromlen);
	return buffer;
}


int test_hook_dns_reply()
{
	// Initialize MinHook.
	if (MH_Initialize() != MH_OK)
	{
		return 1;
	}

	// Create a hook for MessageBoxW, in disabled state.
	if (MH_CreateHook(&recvfrom, &DetourRecvfrom,
		reinterpret_cast<LPVOID*>(&fpRecvfrom)) != MH_OK)
	{
		return 1;
	}

	// or you can use the new helper funtion like this.
	//if (MH_CreateHookApiEx(
	//    L"user32", "recvfrom", &DetourRecvfrom, &fpRecvfrom) != MH_OK)
	//{
	//    return 1;
	//}

	// Enable the hook for MessageBoxW.
	if (MH_EnableHook(&recvfrom) != MH_OK)
	{
		return 1;
	}

	// Expected to tell "Hooked!".
	// TODO: Replace the following with a function that will reveal payload
	//MessageBoxW(NULL, L"Not hooked...", L"MinHook Sample", MB_OK);

	// Disable the hook for MessageBoxW.
	if (MH_DisableHook(&recvfrom) != MH_OK)
	{
		return 1;
	}

	// Expected to tell "Not hooked...".
	MessageBoxW(NULL, L"Not hooked...", L"MinHook Sample", MB_OK);

	// Uninitialize MinHook.
	if (MH_Uninitialize() != MH_OK)
	{
		return 1;
	}

	return 0;

}